<html>

<head>
    <meta charset="utf-8" />
    <title>Image based tracking AR.js demo</title>

    <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

    <script src="https://unpkg.com/networked-aframe@^0.11.0/dist/networked-aframe.min.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js" crossorigin="anonymous"></script>
    <script src="/dist/naf-janus-adapter.js"></script>

    <!-- style for the loader -->
    <style>
        .arjs-loader {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .arjs-loader div {
            text-align: center;
            font-size: 1.25em;
            color: white;
        }
    </style>
</head>

<body style="margin : 0px; overflow: hidden;">
    <!-- a-frame scene -->
    <a-scene 
        vr-mode-ui="enabled: false;" '
        renderer="logarithmicDepthBuffer: true;" 
        embedded
        arjs="
            trackingMethod: best; 
            sourceType: webcam;
            debugUIEnabled: false;" 
        networked-scene="
            room: 1;
            debug: false;
            adapter: janus;
            connectOnLoad: true;
            serverURL: wss://cowebxr.com:8989/janus;">

            <a-assets>

                <img id="grid" src="assets/grid.png" />
                <img id="sky" src="assets/sky.jpg" />
        
                <img id="groundTexture" src="https://cdn.aframe.io/a-painter/images/floor.jpg">
        
                <!-- Templates -->
        
                <!-- Avatar -->
                <template id="avatar-template" type="text/html">
                    <a-entity class="avatar" networked-audio-source>
                        <a-plane color="#fff" width="4" height="3" position="0 .6 0" material="side: back"
                            networked-video-source></a-plane>
                        <a-sphere class="head" color="#5985ff" scale="0.45 0.5 0.4"></a-sphere>
                        <a-entity class="face" position="0 0.05 0">
                            <a-sphere class="eye" color="#efefef" position="0.16 0.1 -0.35" scale="0.12 0.12 0.12">
                                <a-sphere class="pupil" color="#000" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
                            </a-sphere>
                            <a-sphere class="eye" color="#efefef" position="-0.16 0.1 -0.35" scale="0.12 0.12 0.12">
                                <a-sphere class="pupil" color="#000" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
                            </a-sphere>
                        </a-entity>
                    </a-entity>
                </template>
        
                <!-- /Templates -->
            </a-assets>


        <!-- <a-entity camera>
            <a-entity id="player" networked="template:#avatar-template;attachTemplateToLocal:false;" position="0 0 -1"
                rotation="0 0 0" onhover>
            </a-entity>
        </a-entity> -->

        <a-camera look-controls="enabled: false" wasd-controls="enabled: false" position="0.5 0.5 -3.5" fit id="mainCamera">
            <a-entity id="player" networked="template:#avatar-template;attachTemplateToLocal:false;" position="0 0 -1"
                rotation="0 0 0" onhover>
            </a-entity>
        </a-camera>

    </a-scene>

    <script>
        function genClientId() {
            let num = '';
            for (let i = 0; i < 16; i++) {
                num += Math.floor(Math.random() * 10).toString();
            }
            return num;
        }

        // On mobile remove elements that are resource heavy
        var isMobile = AFRAME.utils.device.isMobile();
        // if (isMobile) {
        //     // var particles = document.getElementById('particles');
        //     // particles.parentNode.removeChild(particles);
        // }

        document.addEventListener('DOMContentLoaded', () => {
            const scene = document.querySelector('a-scene');
            scene.addEventListener('adapter-ready', ({ detail: adapter }) => {
                const clientId = genClientId(); 
                adapter.setClientId(clientId);
                navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                    adapter.setLocalMediaStream(stream).then(() => {
                        adapter.enableMicrophone(true);
                        const currentStream = stream;
                        navigator.mediaDevices.getUserMedia(
                            {
                                video: {
                                    mediaSource: "camera",
                                    // width: { max: 1280, ideal: 4096 },
                                    // height: { ideal: 2160 },
                                    // frameRate: { ideal: 60 },
                                    facingMode: { ideal: "environment" }
                                }
                            }).then((stream) => {
                                currentStream.addTrack(stream.getVideoTracks()[0]);
                                adapter.setLocalMediaStream(currentStream);
                            });
                    });
                }).catch(err => {
                    console.warn("Microphone access not allowed. This client will not broadcast audio.");
                });
            });
        });
    </script>

    <script>
        var sceneEl = document.querySelector('a-scene');
        var entityEl = document.createElement('a-entity');
        entityEl.setAttribute('geometry', {
            primitive: 'plane',
            height: 0.5,
            width: 0.25,
        });
        sceneEl.appendChild(entityEl);

        var textEl = document.createElement('a-entity');
        textEl.setAttribute('text', {
            value: '',
            height: 1,
            width: 1
        });
        textEl.setAttribute('id', "recognition");
        textEl.setAttribute('position', { x: 0, y: 0, z: -3 });
        sceneEl.appendChild(textEl);

        function pushData(senderId, dataType, data, targetObj) {
            // console.log(data);
            // console.log(data[0].results.names);

            // const returned_data = JSON.parse(this.responseText);
            // const recognition_results = JSON.parse(returned_data[0].results);

            const yolo_width = 480;
            const yolo_height = 640;
            
            const win_width = window.innerWidth;
            const win_height = window.innerHeight;

            const recognition_results = data[0].results
            const num_rr = recognition_results.bb.length;

            // // console.log("window size " + window.innerWidth + "x" + window.innerHeight);

            if (num_rr > 0) {
                var textElement = document.getElementById("recognition");
                textElement.innerHTML = '';
                for (var i = 0; i < num_rr; i++) {
                    const curr_label = recognition_results.names[i];
                    const curr_res = recognition_results.bb[i];

                    const x_min = curr_res[0];
                    const y_min = curr_res[1];
                    const box_width = curr_res[2];
                    const box_height = curr_res[3];

                    // console.log(curr_res, curr_label);

                    // const x_ratio = win_width / yolo_width;
                    // const y_ratio = win_height / yolo_height;

                    // const x_centre = (x_min + box_width) / 2;
                    // const y_centre = (y_min + box_height) / 2;

                    // const x_cen_new = (x_centre*x_ratio) - x_ratio;
                    // const y_cen_new = (y_centre*y_ratio) - y_ratio;

                    const x_centre = x_min + (box_width / 2);
                    const y_centre = y_min - (box_height / 2);

                    const y_min_new = box_height - y_min - 1;

                    // console.log(x_centre, y_centre);

                    var res_box = document.createElement('a-entity');
                    // res_box.setAttribute('geometry', {
                    //     primitive: 'plane',
                    //     height: box_height,
                    //     width: box_width
                    // });
                    // // res_box.setAttribute('rotation', {x: 0, y: 0, z: -90});
                    // res_box.setAttribute('material', {
                    //     opacity: 0,
                    //     transparent: true
                    // });
                    res_box.setAttribute('position', { x: x_min, y: y_min, z: -2.5 });
                    // res_box.setAttribute('rotation', {x: 180, y: 0, z: 0});

                    var new_el = document.createElement('a-entity');
                    new_el.setAttribute('text', {
                        value: curr_label,
                        height: 1,
                        width: 1
                    });
                    new_el.setAttribute('id', "recognition");
                    new_el.setAttribute('position', { x: x_min, y: y_min, z: -1 });
                    // new_el.setAttribute('rotation', {x: 50, y: 30, z: 0});
                    new_el.setAttribute('material', {
                        side: "double"
                    })
                    res_box.appendChild(new_el);
                    textElement.appendChild(res_box);

                }
            }
    
        }

        // Define custom schema for syncing avatar color, set by random-color
        NAF.schemas.add({
            template: '#avatar-template',
            components: [
                'position',
                'rotation',
                {
                    selector: '.head',
                    component: 'material',
                    property: 'color'
                }
            ]
        });
        // Called by Networked-Aframe when connected to server
        function onConnect() {
            console.log("onConnect", new Date());
            NAF.connection.subscribeToDataChannel('results', pushData);
        }
    </script>
</body>

</html>